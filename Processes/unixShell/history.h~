#include <deque>
#include <utility>
#include <string>
#include <sstream>
#include <vector>
#include <iostream>

using std::cout;
using std::cerr;
using std::deque;
using std::pair;
using std::string;
using std::stringstream;
using std::vector;

class History {
 public:
  History();
  ~History();
  string processCommand(const string& command);
  
 private:
  void update(const string& command);
  string lastCommand() const;
  vector<pair<int,string>> allCommands() const;
  
  static const int size = 10;
  int commandId;
  deque<pair<int,string>> commands;
};

History::History() : commandId(1) {

}

History::~History() {

}

string History::processCommand(const string& command) {
  stringstream ss{command};
  string firstToken;
  getline(ss, firstToken, ' ');
  
  if (firstToken == "history") {
    for (const auto& cmd : commands) {
      cout << cmd.first << " " << cmd.second << "\n";
    }
    return "";
  }
   
  if (firstToken[0] != '!') {
    cout << "here\n";
    update(command);
    return command;
  }

  if (firstToken == "!!") {
    string cmd = lastCommand();
    cout << cmd << "\n";
    update(cmd);
    return cmd;
  }

  string idString(next(command.begin()), command.end());
  int idNumeric = stoi(idString);
  int lowerId = commands.begin()->first;
  cout << idNumeric << "\n";
  if (idNumeric >= lowerId && idNumeric < commandId) {
    string cmd = commands[idNumeric - lowerId].second;
    cout << cmd << "\n";
    update(cmd);
    return cmd;
  }

  cerr << "No such command in history.\n";
  return "";
}

void History::update(const string& command) {
  commands.emplace_back(make_pair(commandId, command));
  if (commands.size() > size) commands.pop_front();
  commandId++;
}

string History::lastCommand() const {
  return commands.back().second;
}

vector<pair<int,string>> History::allCommands() const {
  vector<pair<int,string>> result(commands.begin(), commands.end());
  return result;
}

