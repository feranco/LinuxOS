#include <iostream>
#include <sstream>
#include <string>
#include <unistd.h>
#include <sys/wait.h>
#include <cstring>
#include "history.h"
#define MAX_ARGUMENTS 10
#define MAX_LINE 80

using std::cin;
using std::cout;
using std::getline;
using std::stringstream;
using std::string;
using std::vector;

class Shell {
 public:
  Shell (const string& s);
  void Run();
 private:
  int parseCommand(const string& command, char** cmd, char** args);
  string prompt;
 
};

Shell::Shell(const string& s) {
  prompt = s + ">";
};

void Shell::Run() {
  char *args[MAX_ARGUMENTS] = {(char*)nullptr}; /* command line arguments */
  char* cmd = nullptr;
  int should_run = 1; /* flag to determine when to exit program */
  History history;
  while (should_run) {
  
    cout << prompt;
    string command;
    getline(cin, command);
    command = history.processCommand(command);
    
    if (command.empty()) continue;
    
    int nArgs = parseCommand(command, &cmd, args);
    bool isChildConcurrent = !strcmp(const_cast<char*>(args[nArgs-1]),"&");

    if(isChildConcurrent) {
      delete[] args[nArgs-1];
      args[nArgs-1] = nullptr;
    }

    pid_t pid;
    pid = fork();
    
    if (pid > 0) {
      //parent
      if (!isChildConcurrent) {
	wait(nullptr);
      }
    }
    else if (pid == 0) {
      execv(cmd,args);
      std::cerr << "Execv not executed \n";
    }
  }
}

int Shell::parseCommand(const string& command, char** cmd, char** args) {
  stringstream ss(command);
  string arg;
  string cmdPath = "/bin/";
  
  int nArgs = 0;
  while (getline(ss, arg, ' ')) {
    args[nArgs] = new char[arg.size()+1];
    std::strcpy (args[nArgs], arg.c_str());
    nArgs++;
  }

  cmdPath += string(args[0]);
  *cmd = new char[80];
  std::strcpy (*cmd, cmdPath.c_str());

  return nArgs;
}
